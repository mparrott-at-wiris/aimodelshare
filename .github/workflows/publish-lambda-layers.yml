name: Publish AWS Lambda Layers

on:
  workflow_dispatch:
    inputs:
      python_runtime:
        description: "Target Python runtime for layer compatibility (e.g., python3.11 or python3.12)"
        required: true
        default: "python3.12"
      make_public:
        description: "Grant public GetLayerVersion permission (true/false)"
        required: true
        default: "true"
      eval_requirements_file:
        description: "Path to eval layer requirements file"
        required: true
        default: "requirements-eval.txt"
      auth_requirements_file:
        description: "Path to auth layer requirements file"
        required: true
        default: "requirements-auth.txt"
      eval_layer_name:
        description: "Eval layer base name"
        required: true
        default: "eval-layer"
      auth_layer_name:
        description: "Auth layer base name"
        required: true
        default: "aimsauth-layer"

permissions:
  contents: read

env:
  REGIONS: "us-east-1 eu-west-1"

jobs:
  matrix-setup:
    runs-on: ubuntu-latest
    outputs:
      layers: ${{ steps.set-matrix.outputs.layers }}
      regions: ${{ steps.set-regions.outputs.regions_json }}
      sanitized_runtime: ${{ steps.sanitize-runtime.outputs.sanitized_runtime }}
    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - id: set-matrix
        run: |
          layers_json=$(jq -n -c \
            --arg eval_req "${{ github.event.inputs.eval_requirements_file }}" \
            --arg auth_req "${{ github.event.inputs.auth_requirements_file }}" \
            --arg eval_name "${{ github.event.inputs.eval_layer_name }}" \
            --arg auth_name "${{ github.event.inputs.auth_layer_name }}" \
            '[
              {"id": "eval", "name": $eval_name, "requirements": $eval_req, "src_dir": "layer-src/eval"},
              {"id": "auth", "name": $auth_name, "requirements": $auth_req, "src_dir": "layer-src/auth"}
            ]')
          echo "layers=${layers_json}" >> "$GITHUB_OUTPUT"

      - id: set-regions
        run: |
          regions_json=$(echo "${{ env.REGIONS }}" | jq -R 'split(" ") | map(select(length > 0))' | jq -c .)
          echo "regions_json=${regions_json}" >> "$GITHUB_OUTPUT"

      - id: sanitize-runtime
        run: |
          sanitized=$(echo "${{ github.event.inputs.python_runtime }}" | tr '.' '-')
          echo "sanitized_runtime=$sanitized" >> "$GITHUB_OUTPUT"

  publish-layers:
    needs: matrix-setup
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        layer: ${{ fromJson(needs.matrix-setup.outputs.layers) }}
        region: ${{ fromJson(needs.matrix-setup.outputs.regions) }}

    env:
      PYTHON_RUNTIME: ${{ github.event.inputs.python_runtime }}           # e.g. python3.12 (keep dot for compatible runtimes)
      REQUIREMENTS_FILE: ${{ matrix.layer.requirements }}
      LAYER_SRC_DIR: ${{ matrix.layer.src_dir }}
      BUILD_DIR: layer_build
      ZIP_FILE_NAME: ${{ matrix.layer.id }}_layer.zip
      MAKE_PUBLIC: ${{ github.event.inputs.make_public }}
      AWS_ACCESS_KEY_ID: ${{ secrets.DATA_AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.DATA_AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ matrix.region }}
      LAYER_NAME: ${{ matrix.layer.name }}-${{ needs.matrix-setup.outputs.sanitized_runtime }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq (needed for parsing aws output)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Derive numeric Python version
        id: derive
        run: |
          version=$(echo "${{ env.PYTHON_RUNTIME }}" | sed -n 's/^python\([0-9]\+\.[0-9]\+\).*$/\1/p')
          if [ -z "$version" ]; then
            echo "::error::Failed to derive Python version from ${{ env.PYTHON_RUNTIME }}"
            exit 1
          fi
          echo "version=$version" >> $GITHUB_OUTPUT

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ steps.derive.outputs.version }}

      - name: Upgrade pip
        run: python -m pip install --upgrade pip

      - name: Prepare build dir
        run: |
          rm -rf "${{ env.BUILD_DIR }}" && mkdir -p "${{ env.BUILD_DIR }}/python"
          if [[ ! -f "${{ env.REQUIREMENTS_FILE }}" ]]; then
            echo "::error::Requirements file '${{ env.REQUIREMENTS_FILE }}' not found"
            exit 1
          fi
          echo "Using requirements: ${{ env.REQUIREMENTS_FILE }}"

      - name: (Optional) Copy custom source
        run: |
          if [ -d "${{ env.LAYER_SRC_DIR }}" ]; then
            cp -R "${{ env.LAYER_SRC_DIR }}/." "${{ env.BUILD_DIR }}/python/"
          fi

      - name: Install dependencies
        run: |
          pip install -r "${{ env.REQUIREMENTS_FILE }}" -t "${{ env.BUILD_DIR }}/python"

      - name: Prune files
        working-directory: ${{ env.BUILD_DIR }}/python
        run: |
          find . -type d -name tests -exec rm -rf {} +
          find . -type d -name __pycache__ -exec rm -rf {} +
          find . -name "*.pyc" -delete

      - name: Zip layer
        working-directory: ${{ env.BUILD_DIR }}
        run: zip -r9 "../${{ env.ZIP_FILE_NAME }}" python

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Publish layer
        id: publish
        run: |
          DESC="${{ env.LAYER_NAME }} build $(date +%Y%m%d-%H%M%S) (${{ env.PYTHON_RUNTIME }})"
          publish_output=$(aws lambda publish-layer-version \
            --layer-name "${{ env.LAYER_NAME }}" \
            --description "$DESC" \
            --zip-file "fileb://${{ env.ZIP_FILE_NAME }}" \
            --compatible-runtimes "${{ env.PYTHON_RUNTIME }}" \
            --region "${{ env.AWS_REGION }}" \
            --license-info "MIT" \
            --output json)
          layer_version_arn=$(echo "$publish_output" | jq -r '.LayerVersionArn')
          layer_version=$(echo "$publish_output" | jq -r '.Version')
          mkdir -p results
          if [ -z "$layer_version_arn" ] || [ "$layer_version_arn" = "null" ]; then
            echo "${{ env.AWS_REGION }} FAILED -" >> results/publish_results_${{ matrix.layer.id }}.txt
            exit 1
          fi
          echo "${{ env.AWS_REGION }} ${layer_version} ${layer_version_arn}" >> results/publish_results_${{ matrix.layer.id }}.txt
          if [[ "${{ env.MAKE_PUBLIC }}" == "true" ]]; then
            aws lambda add-layer-version-permission \
              --layer-name "${{ env.LAYER_NAME }}" \
              --version-number "${layer_version}" \
              --statement-id "public-access-${layer_version}-${{ env.AWS_REGION }}" \
              --action lambda:GetLayerVersion \
              --principal '*' \
              --region "${{ env.AWS_REGION }}" || echo "::warning::Failed to add public permission."
          fi

      - name: Upload publish result
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: publish-results-${{ matrix.layer.id }}-${{ matrix.region }}
          path: results/publish_results_${{ matrix.layer.id }}.txt
          retention-days: 1

  aggregate-report:
    if: always()
    needs: publish-layers
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v4
        with:
          pattern: publish-results-*
          path: results

      - id: report
        run: |
          echo "# Lambda Layer Publish Report" > REPORT.md
          echo "" >> REPORT.md
          echo "**Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> REPORT.md
          echo "**Python Runtime:** ${{ github.event.inputs.python_runtime }}" >> REPORT.md
          echo "**Made Public:** ${{ github.event.inputs.make_public }}" >> REPORT.md
          echo "" >> REPORT.md
          for layer_id in eval auth; do
            if [[ "$layer_id" == "eval" ]]; then layer_base="${{ github.event.inputs.eval_layer_name }}"; fi
            if [[ "$layer_id" == "auth" ]]; then layer_base="${{ github.event.inputs.auth_layer_name }}"; fi
            sanitized_runtime=$(echo "${{ github.event.inputs.python_runtime }}" | tr '.' '-')
            echo "## Layer: ${layer_base}-${sanitized_runtime} (${layer_id})" >> REPORT.md
            echo "" >> REPORT.md
            echo "| Region | Status/Version | ARN |" >> REPORT.md
            echo "|--------|----------------|-----|" >> REPORT.md
            found_layer_results=false
            while IFS= read -r -d $'\0' file; do
              if [[ -f "$file" && -s "$file" ]]; then
                found_layer_results=true
                while IFS= read -r line; do
                  region=$(echo "$line" | awk '{print $1}')
                  version=$(echo "$line" | awk '{print $2}')
                  arn=$(echo "$line" | awk '{print $3}')
                  if [[ "$version" == "FAILED" ]]; then
                    echo "| $region | FAILED | - |" >> REPORT.md
                  else
                    echo "| $region | $version | \`$arn\` |" >> REPORT.md
                  fi
                done < "$file"
              fi
            done < <(find results -name "publish_results_${layer_id}.txt" -print0)
            if [[ "$found_layer_results" == "false" ]]; then
              echo "| *All Regions* | *No results found* | - |" >> REPORT.md
            fi
            echo "" >> REPORT.md
          done
          echo "---" >> REPORT.md
          echo "*Report generated at $(date -u)*" >> REPORT.md
          cat REPORT.md

      - uses: actions/upload-artifact@v4
        with:
          name: layer-publish-report-${{ github.run_id }}
          path: REPORT.md
